#!/usr/bin/env python3
import sys
import os
import argparse

def main():
    """
    CMS Analysis Framework Generator
    
    This script automates the creation of a ROOT analysis workspace.
    1. Opens a sample ROOT file.
    2. Runs TTree::MakeClass to generate the Analyzer skeleton.
    3. Generates a C++ main entry point (main.cc) to handle file lists.
    4. Generates a Makefile for immediate compilation.
    """

    # --- 1. Argument Parsing ---
    parser = argparse.ArgumentParser(description="Generate a CMS ROOT Analysis Framework via MakeClass")
    parser.add_argument("-f", "--file", required=True, help="Path to a sample ROOT file (e.g., samples/ttHH.root)")
    parser.add_argument("-t", "--tree", default="Events", help="Name of the TTree in the file (default: Events)")
    parser.add_argument("-c", "--class", dest="classname", default="CMSAnalyzer", help="Name of the Analyzer class to generate (default: CMSAnalyzer)")
    
    args = parser.parse_args()
    
    sample_file = args.file
    tree_name = args.tree
    class_name = args.classname

    print("-" * 60)
    print(f"[INFO] Initializing Framework Generation")
    print(f"[INFO] Sample File : {sample_file}")
    print(f"[INFO] Tree Name   : {tree_name}")
    print(f"[INFO] Class Name  : {class_name}")
    print("-" * 60)

    # --- 2. Check ROOT Availability ---
    try:
        import ROOT
    except ImportError:
        print("[ERROR] Could not import ROOT module. Please ensure ROOT is set up (source /cvmfs/...).")
        sys.exit(1)

    # --- 3. Run MakeClass via PyROOT ---
    if not os.path.exists(sample_file):
        print(f"[ERROR] Sample file not found: {sample_file}")
        sys.exit(1)

    print(f"[INFO] Opening file to extract TTree structure...")
    
    # Open file in read-only mode
    f = ROOT.TFile.Open(sample_file, "READ")
    if not f or f.IsZombie():
        print(f"[ERROR] Failed to open file: {sample_file}")
        sys.exit(1)

    # Get the tree
    tree = f.Get(tree_name)
    if not tree:
        print(f"[ERROR] TTree '{tree_name}' not found in file.")
        f.Close()
        sys.exit(1)

    print(f"[INFO] Found TTree '{tree_name}' with {tree.GetEntries()} entries.")
    print(f"[INFO] Running MakeClass('{class_name}')...")
    
    # Run MakeClass
    # This generates {class_name}.h and {class_name}.C in the current directory
    prev_dir = os.getcwd()
    ROOT.gROOT.SetBatch(True) # Prevent graphical windows
    tree.MakeClass(class_name)
    f.Close()

    if os.path.exists(f"{class_name}.C") and os.path.exists(f"{class_name}.h"):
        print(f"[SUCCESS] Generated {class_name}.C and {class_name}.h")
    else:
        print("[ERROR] MakeClass failed to generate files.")
        sys.exit(1)


    # --- 4. Generate main.cc ---
    main_filename = "main.cc"
    print(f"[INFO] Generating C++ entry point: {main_filename}...")
    
    main_code = f"""/**
 * @file {main_filename}
 * @brief Main driver for {class_name}. Reads a file list and executes the Loop.
 * Auto-generated by setup_framework.py
 */

#include "{class_name}.h"
#include <iostream>
#include <fstream>
#include <string>
#include "TChain.h"
#include "TString.h"

int main(int argc, char* argv[]) {{
    // Check command line arguments
    if (argc < 2) {{
        std::cout << "Usage: " << argv[0] << " <file_list.txt> [output_filename]" << std::endl;
        return 1;
    }}

    std::string listFileName = argv[1];
    std::cout << "[Main] Processing file list: " << listFileName << std::endl;

    // Create TChain
    // NOTE: Ensure this matches the Tree Name used during generation
    TChain *chain = new TChain("{tree_name}");

    // Read file list
    std::ifstream infile(listFileName);
    std::string line;
    int nFiles = 0;

    if (infile.is_open()) {{
        while (std::getline(infile, line)) {{
            // Skip empty lines or comments
            if (line.empty() || line[0] == '#') continue;
            chain->Add(line.c_str());
            nFiles++;
        }}
        infile.close();
    }} else {{
        std::cout << "[Error] Cannot open file list!" << std::endl;
        return 1;
    }}

    std::cout << "[Main] Total " << nFiles << " files added to TChain." << std::endl;

    // Initialize Analyzer
    {class_name} t(chain);
    
    std::cout << "[Main] Starting Event Loop..." << std::endl;
    t.Loop();
    std::cout << "[Main] Analysis Finished." << std::endl;

    return 0;
}}
"""
    with open(main_filename, "w") as f_main:
        f_main.write(main_code)


    # --- 5. Generate Makefile ---
    makefile_name = "Makefile"
    print(f"[INFO] Generating Makefile: {makefile_name}...")

    makefile_code = f"""# Auto-generated Makefile for {class_name}

# Compiler and Flags
CXX = g++
CXXFLAGS = -O2 -Wall -fPIC $(shell root-config --cflags)
LDFLAGS = $(shell root-config --libs)

# Target Executable Name
TARGET = runAnalysis

# Source Files
# We compile main.cc and the Analyzer source (.C)
SRCS = {main_filename} {class_name}.C
OBJS = $(SRCS:.cc=.o)
OBJS := $(OBJS:.C=.o)

# Default Target
all: $(TARGET)

# Link
$(TARGET): $(OBJS)
	$(CXX) -o $@ $^ $(LDFLAGS)
	@echo "-----------------------------------------"
	@echo " Compilation Successful! Executable: ./$(TARGET)"
	@echo "-----------------------------------------"

# Compile .cc files (main)
%.o: %.cc
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Compile .C files (Analyzer)
%.o: %.C
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Clean
clean:
	rm -f $(OBJS) $(TARGET)
"""
    with open(makefile_name, "w") as f_make:
        f_make.write(makefile_code)

    print("-" * 60)
    print(f"[DONE] Framework generation complete.")
    print(f"       1. Edit '{class_name}.C' to add your analysis logic (inside Loop).")
    print(f"       2. Run 'make' to compile.")
    print(f"       3. Run './runAnalysis <file_list.txt>' to execute.")
    print("-" * 60)

if __name__ == "__main__":
    main()
